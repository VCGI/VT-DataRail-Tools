#PURPOSE
#   For a given data item (feature class, table, raster, etc.) OR a given HTML file that
#   previously produced by this tool, interacts w/ user via a GUI to produce 2 metadata
#   files that are populated for ISO-Core metadata-elements per the VT GIS Metadata
#   Standard.
#
#   One metadata file is an "ISO 19139" XML-file--which contains "ISO 19115 NAP"-format
#   metadata--for importing metadata into a data item (e.g., geodatabase feature-class) in
#   ArcCatalog.
#
#   The other metadata file is an HTML file that stores and presents the metadata.
#
#   Can be used to quickly produce NEW compliant metadata or update metadata that was
#   PREVIOUSLY PRODUCED BY THIS TOOL.
#
#   By design, this script doesn't overwrite its output to the given data-item's metadata.
#   Importing metadata overwrites pre-existing metadata. The "Import Metadata (Conversion)"
#   tool can be used to import a metadata-XML file to a data item's metadata (again,
#   pre-existing metadata is overwritten).
#
#   Before importing this script's output to a data item, make sure that the data item
#   is the data item to which the metadata should be imported (and overwritten).

#README NOTES
#   This script requires an initialization file (vtDataRail_WriteCoreMetadata.INI.xml) in its
#   directory. The .INI.xml file is an XML file that is used for setting certain default
#   metadata-element content. The XML file has a simple structure and specification for easy
#   editing. Out of the box, this script comes with a vtDataRail_WriteCoreMetadata.INI.xml
#   file in its directory.
#
#   The structure for vtDataRail_WriteCoreMetadata.INI.xml is:
#
#      <?xml version="1.0"?>
#      <SETTINGS>
#         <SETTING name="">
#            ...setting's value goes here...
#         </SETTING>
#         <SETTING name="">
#            ...setting's value goes here...
#         </SETTING>
#      </SETTINGS>
#
#   The SETTING-element 'name' attributes and contents are:
#      'name' Attribute       Contents
#      ---------------------  -----------------------------------------------------------------
#      abstract               Brief summary of dataset’s contents (1 or a few sentences).
#                             Can insert a standard disclaimer here.
#
#      poc_org                Dataset POC as an organization name, e.g., VT Agency of Natural
#                             Resources.
#
#      poc_individual         Dataset POC as an individual name.
#
#      poc_role               Dataset POC as a role, e.g., Database Administrator.
#
#      topics                 Dataset's topic categories. Choose 1 or more from from (farming,biota,
#                             boundaries,climatologyMeteorologyAtmosphere,economy,elevation,
#                             environment,geoscientificInformation,health,
#                             imageryBaseMapsEarthCover,intelligenceMilitary,inlandWaters,
#                             location,oceans,planningCadastre,society,structure,transportation,
#                             utilitiesCommunication). In .INI.xml file. separate topics with a ','.
#
#      extent_xmin            West boundary of dataset's extent, in decimal degrees.
#
#      extent_ymin            South boundary of dataset's extent, in decimal degrees.
#
#      extent_xmax            East boundary of dataset's extent, in decimal degrees.
#
#      extent_ymax            North boundary of dataset's extent, in decimal degrees.
#
#   NOTE: .INI.xml content is only in-play for attributes not already populated in input data-item
#         or input HTML file.
#
#   When this script writes the output HTML-metadata file, it writes a Python dictionairy object named
#   named "MetaContainer" into a commented area. The MetaContainer stores metadata content. When an
#   HTML metadata-file is given to this tool (file must have been previously created by this tool),
#   this tool looks for and reads the MetaContainer.
#
#   Read an HTML file's comments in its source code to determine if it was generated by this tool.
#
#   This script has a seed XML-file in its directory (vtDataRail_WriteCoreMetadata.SEED.xml),
#   which is an internal XML-file that the script uses to start creating XML files. DON'T ALTER
#   IT unless you are forking/branching the script's codebase; CONSIDER IT TO BE A PART OF THE
#   CODEBASE.
#
#   In case you aren't very familiar with how metadata is stored and processed in ArcGIS...
#   The ArcGIS metadata format is a container of other formats (e.g., ISO 19115 NAP, FGDC
#   CSDGM, etc.). Metadata that is wired into an ArcGIS data-item (e.g., a feature class) is
#   always stored in the ArcGIS format; ArcGIS-format metadata contains elements that are
#   translatable to any ArcGIS-supported metadata standard PLUS some elements (e.g.,
#   thumbnail, geoprocessing history, etc.) that are only in the ArcGIS metadata format.
#
#   A metadata style is an ArcGIS setting that determines how metadata is viewed and edited
#   in the ArcGIS metadata editor. If a standard-related style (e.g., ISO 19115 NAP) is
#   applied, the metadata editor shows all elements of that style PLUS ArcGIS elements
#   that are extraneous to that style (e.g., thumbnail, geoprocessing history, etc.). An
#   execption to style yielding a superset is the Item Description style, which only shows
#   a subset of ArcGIS-metadata elements--even if the underlying metadata has been edited
#   to include content beyond the Item Description style.
#
#   To select a metadata style in ArcGIS Desktop:
#      Customize | *Options | Metadata tab
#
#   In ArcGIS Open Data, metadata that is imported to an item must be in the ArcGIS
#   metadata-format. ArcGIS Online has a setting that determines the metadata style
#   (e.g., ISO 19115 NAP, FGDC CSDGM) in which metadata is presented via ArcGIS Open Data.

#HOW TO USE
#   Run as a script tool; pass in arguments per arguments described in script's section that
#   is commented w/:
#      #***** GET ARGUMENTS *****.

#HISTORY
#   DATE         ORGANIZATION     PROGRAMMER          NOTES
#   09/10/2019   VCGI             Ivan Brown          First stable release. Built w/ ArcGIS
#                                                     Desktop (arcpy) 10.6.1 and Python 2.7.14.

#PSEUDO CODE
#   Set major variables (via script arguments):
#      -data item (Data Element)
#      ***OR***
#      -HTML file previously produced by this tool
#
#   Get info from vtDataRail_WriteCoreMetadata.INI.xml.
#
#   If given a data item, get info on data item via arcpy.Describe() and arcpy.ListFields()
#   Otherwise, find, read, and capture MetaContainer object in given HTML file
#
#   Open GUI for filling metadata. User can save metadata from GUI.
#
#   Write output metadata-XML file and metadata-HTML file.

#IMPORT MODULES
print "IMPORTING MODULES..."
import time, sys, arcpy, os.path, Tkinter, shutil, copy, ast
import xml.etree.ElementTree as ET

#***** GET ARGUMENTS *****
#
#      PASS ARGUMENTS (3 arguments) TO SCRIPT IN SAME ORDER AS PRESENTED HERE, WHICH IS:
#
#         <data_item> <HTML_file> <output_folder>
#
#If giving script a data item for which metadata is to be written, set "data_item" argument to Data Element item for which metadata is to be written.
#Otherwise, set "data_item" argument to "".
data_item = arcpy.GetParameterAsText(0)
#
#If giving script an HTML-metadata file that was previously produced by this script, set HTML_file argument to path of that HTML file.
#Otherwise, set "HTML_file" argument to "". THE "HTML_file" argument is ignored if the "data_item" argument isn't "".
HTML_file = arcpy.GetParameterAsText(1)
#
#Set "output_folder" argument to path of a folder to contain output metadata-files (XML and HTML).
#Output metadata files are named this way*:
#
#   ISO metadata-file:        <name>.xml
#   HTML metadata-file:       <name>.xml
#
#   *If an output file already exists, the new output-file is named w/ an integer on the
#   end (e.g., CityParks2.xml).
output_folder = arcpy.GetParameterAsText(2)
#***** END OF SECTION FOR GETTING ARGUMENTS *****

#CONSTANTS
#ISO_NS is a dictionary that relates XML-namespace names to corresponding URLs
ISO_NS = {"gmd":"http://www.isotc211.org/2005/gmd","gco":"http://www.isotc211.org/2005/gco","gts":"http://www.isotc211.org/2005/gts","srv":"http://www.isotc211.org/2005/srv","gml":"http://www.opengis.net/gml","xlink":"http://www.w3.org/1999/xlink","xsi":"http://www.w3.org/2001/XMLSchema-instance"}

#FUNCTIONS

#THIS FUNCTION CAPTURES A GIVEN STRING AND MAKES NOTE WITH IT PER ARGUMENTS
#   ARGUMENT 1 (STRING): THE STRING.
#   ARGUMENT 2 (INTEGER >= 0 AND <= 2): SET TO 0 IF NOTING INFO, 1 IF NOTING A WARNING, OR 2 IF NOTING AN ERROR.
def make_note(the_note, severity = 0):
   print the_note
   if severity == 0:
      arcpy.AddMessage(the_note)
   elif severity == 1:
      arcpy.AddWarning(the_note)
   else:
      arcpy.AddError(the_note)

#THIS FUNCTION SIMPLY CAPTURES THE CURRENT DATE AND RETURNS IT IN A PRESENTABLE
#   TEXT FORMAT YYYY-MM-DD.
#   FOR EXAMPLE:
#      2019-04-30
def tell_the_time():
   s = time.localtime()
   the_year = str(s.tm_year)
   the_month = str(s.tm_mon)
   the_day = str(s.tm_mday)
   #FORMAT THE MONTH TO HAVE 2 CHARACTERS
   while len(the_month) < 2:
      the_month = "0" + the_month
   #FORMAT THE DAY TO HAVE 2 CHARACTERS
   while len(the_day) < 2:
      the_day = "0" + the_day
   the_output = the_year + "-" + the_month + "-" + the_day
   return the_output

#THIS FUNCTION LOOKS FOR A PARTICULAR SUB ELEMENT OF A GIVEN ELEMENT
#   ARGUMENT 1 IS THE PARENT ELEMENT.
#   ARGUMENT 2 IS THE SUB ELEMENT.
#   ARGUMENT 3 (OPTIONAL) IS A DICTIONARY THAT RELATES XML-NAMESPACE NAMES TO CORRESPONDING URLs.
#               FOR EXAPMLE, A GIVEN SUB-ELEMENT'S TAG LOOKS LIKE THIS INTERNALLY IN THE XML:
#                  {http://www.isotc211.org/2005/gco}CharacterString
#                  THE DICTIONARY RELATES "gco" TO "http://www.isotc211.org/2005/gco", SO THAT THE SUB-ELEMENTS ARE SEARCHED W/ A GIVEN SUB-ELEMENT TAG THAT LOOKS LIKE THIS:
#                    gco:CharacterString
#               DEFAULT IS None
#RETURNS A LIST OF SUB-ELEMENT OBJECTS
def find_sub(the_element, the_sub, the_namespaces = None):
   sub_list = []
   for i in the_element:
      the_str = i.tag
      #IF NAMESPACE DICTIONARY GIVEN, TRANSLATE
      if the_namespaces != None:
         if the_str[0:1] == "{":
            j = the_str.find("}")
            if j != -1:
               the_url = the_str[1:j]
               for k in the_namespaces:
                  if the_namespaces[k] == the_url:
                     the_str = k + ":" + the_str[j + 1:len(the_str)]
      if the_str.lower() == the_sub.lower():
         sub_list.append(i)
   return sub_list

#THIS FUNCTION TAKES:
#   ARGUMENT 1: AN ELEMENT OBJECT
#   ARGUMENT 2: AN ELEMENT-OBJECT PATH, RELATIVE TO ARGUMENT-1 ELEMENT OBJECT (USE FORWARD SLASHES!)
#                  FOR EXAMPLE:
#                     Movies/Movie represents a path relative to "Theater" ELEMENT:
#                        <Theater>
#                           <Movies>
#                              <Movie>Bee Movie</Movie>
#                              <Movie>Boss Baby</Movie>
#   ARGUMENT 3: (OPTIONAL) A DICTIONARY THAT RELATES XML-NAMESPACE NAMES TO CORRESPONDING URLs.
#               FOR EXAPMLE, A GIVEN ELEMENT TAG LOOKS LIKE THIS:
#                  <gco:CharacterString>
#                  THE DICTIONARY RELATES "gco" TO "http://www.isotc211.org/2005/gco", SO THAT THE ELEMENTS ARE SEARCHED W/ THIS:
#                    {http://www.isotc211.org/2005/gco}CharacterString
#               DEFAULT IS None
#RETURNS A LIST OF SUB-ELEMENT OBJECTS THAT ARE ON ACCORD W/ THE PATH'S ENDING ELEMENT.
def find_sub_by_path(the_element, the_path, the_namespaces = None):
   #IF NAMESPACE DICTIONARY GIVEN, TRANSLATE
   if the_namespaces != None:
      the_path = the_path.split("/")
      i = 0
      while i < len(the_path):
         j = the_path[i].find(":")
         if j != -1:
            the_ns = the_path[i][0:j]
            if the_ns in the_namespaces:
               the_path[i] = "{" + the_namespaces[the_ns] + "}" + the_path[i][j + 1:len(the_path[i])]
         i += 1
      new_path = ""
      i = 0
      while i < len(the_path):
         new_path += the_path[i]
         if i < len(the_path) - 1:
            new_path += "/"
         i += 1
      the_path = new_path
   #RETURN ALL ELEMENTS THAT ARE ON ACCORD W/ GIVEN PATH
   return the_element.findall(the_path)

#THIS FUNCTION TAKES A DICTIONARY (A "MetaContainer") OF INFO COLLECTED FROM INPUT AND WRITES THAT INFO TO A METADATA-XML FILE AND TO AN HTML FILE
def metadata_writer(the_dictionary):
   make_note("Preparing output XML...")
   #SET UP NAMESPACES
   for i in ISO_NS:
      if i.lower() == "gmd":
         ET.register_namespace("","http://www.isotc211.org/2005/gmd")
      else:
         ET.register_namespace(i, ISO_NS[i])
   the_seed = ET.parse(sys.path[0] + "\\vtDataRail_WriteCoreMetadata.SEED.xml")
   the_root = the_seed.getroot()
   #title
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:title/gco:CharacterString", ISO_NS)[0].text = the_dictionary['title']
   #abstract
   #(REPLACE HARD RETURNS W/ <P> AND <DIV> TO MAKE CONTENT PRESENT BETTER IN ArcGIS METADATA)
   the_string = the_dictionary['abstract']
   if the_string.find("\n") != -1:
      the_string = the_string.replace("\n\n", "<p></p>")
      the_string = "<div>" + the_string + "</div>"
      the_string = the_string.replace("\n", "</div><div>")
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:abstract/gco:CharacterString", ISO_NS)[0].text = the_string
   #dates...
   the_dates = find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:citation/gmd:CI_Citation/gmd:date", ISO_NS)
   for i in the_dates:
      #data_date_creation
      if find_sub_by_path(i, "gmd:CI_Date/gmd:dateType/gmd:CI_DateTypeCode", ISO_NS)[0].text.lower() == "creation":
         find_sub_by_path(i, "gmd:CI_Date/gmd:date/gco:Date", ISO_NS)[0].text = the_dictionary['data_date_creation']
      #data_date_publication
      if find_sub_by_path(i, "gmd:CI_Date/gmd:dateType/gmd:CI_DateTypeCode", ISO_NS)[0].text.lower() == "publication":
         find_sub_by_path(i, "gmd:CI_Date/gmd:date/gco:Date", ISO_NS)[0].text = the_dictionary['data_date_publication']
      #data_date_revision
      if find_sub_by_path(i, "gmd:CI_Date/gmd:dateType/gmd:CI_DateTypeCode", ISO_NS)[0].text.lower() == "revision":
         find_sub_by_path(i, "gmd:CI_Date/gmd:date/gco:Date", ISO_NS)[0].text = the_dictionary['data_date_revision']
   #poc_org
   find_sub_by_path(the_root, "gmd:contact/gmd:CI_ResponsibleParty/gmd:organisationName/gco:CharacterString", ISO_NS)[0].text = the_dictionary['poc_org']
   #poc_individual
   find_sub_by_path(the_root, "gmd:contact/gmd:CI_ResponsibleParty/gmd:individualName/gco:CharacterString", ISO_NS)[0].text = the_dictionary['poc_individual']
   #poc_role
   find_sub_by_path(the_root, "gmd:contact/gmd:CI_ResponsibleParty/gmd:positionName/gco:CharacterString", ISO_NS)[0].text = the_dictionary['poc_role']
   #topics
   if the_dictionary['topics'] != "":
      topics_list = the_dictionary['topics'].split(",")
      place_for_topics = find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification", ISO_NS)[0]
      first_topic = find_sub_by_path(place_for_topics, "gmd:topicCategory", ISO_NS)[0]
      first_topic.append(ET.Element("{" + ISO_NS['gmd'] + "}MD_TopicCategoryCode"))
      first_topic[0].text = topics_list[0]
      i = 1
      while i < len(topics_list):
         a_new_topic = copy.deepcopy(first_topic)
         a_new_topic[0].text = topics_list[i]
         place_for_topics.append(a_new_topic)
         i += 1
   #extent_xmin
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:geographicElement/gmd:EX_GeographicBoundingBox/gmd:westBoundLongitude/gco:Decimal", ISO_NS)[0].text = the_dictionary['extent_xmin']
   #extent_ymin
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:geographicElement/gmd:EX_GeographicBoundingBox/gmd:southBoundLatitude/gco:Decimal", ISO_NS)[0].text = the_dictionary['extent_ymin']
   #extent_xmax
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:geographicElement/gmd:EX_GeographicBoundingBox/gmd:eastBoundLongitude/gco:Decimal", ISO_NS)[0].text = the_dictionary['extent_xmax']
   #extent_ymax
   find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:extent/gmd:EX_Extent/gmd:geographicElement/gmd:EX_GeographicBoundingBox/gmd:northBoundLatitude/gco:Decimal", ISO_NS)[0].text = the_dictionary['extent_ymax']
   #sref_codespace
   find_sub_by_path(the_root, "gmd:referenceSystemInfo/gmd:MD_ReferenceSystem/gmd:referenceSystemIdentifier/gmd:RS_Identifier/gmd:codeSpace/gco:CharacterString", ISO_NS)[0].text = the_dictionary['sref_codespace']
   #sref_code
   find_sub_by_path(the_root, "gmd:referenceSystemInfo/gmd:MD_ReferenceSystem/gmd:referenceSystemIdentifier/gmd:RS_Identifier/gmd:code/gco:CharacterString", ISO_NS)[0].text = the_dictionary['sref_code']
   #metadata_date
   find_sub_by_path(the_root, "gmd:dateStamp/gco:Date", ISO_NS)[0].text = the_dictionary['metadata_date']
   #metadata_language
   language_subpart = the_dictionary['metadata_language'].split(";")[0].strip()
   the_element = find_sub_by_path(the_root, "gmd:language/gmd:LanguageCode", ISO_NS)[0]
   the_element.set("codeListValue", language_subpart)
   the_element.text = the_dictionary['metadata_language']
   #metadata_charset
   the_element = find_sub_by_path(the_root, "gmd:characterSet/gmd:MD_CharacterSetCode", ISO_NS)[0]
   the_element.set("codeListValue", the_dictionary['metadata_charset'])
   the_element.text = the_dictionary['metadata_charset']
   #data_language
   the_element = find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:language/gmd:LanguageCode", ISO_NS)[0]
   the_element.set("codeListValue", the_dictionary['data_language'])
   the_element.text = the_dictionary['data_language']
   #data_charset
   the_element = find_sub_by_path(the_root, "gmd:identificationInfo/gmd:MD_DataIdentification/gmd:characterSet/gmd:MD_CharacterSetCode", ISO_NS)[0]
   the_element.set("codeListValue", the_dictionary['data_charset'])
   the_element.text = the_dictionary['data_charset']
   #FIGURE OUT BASE-NAME TO USE FOR FILE NAMES
   if input_type == 'item':
      the_name = arcpy.Describe(data_item).baseName
   else:
      the_name = HTML_file[0:HTML_file.rfind(".")]
   out_ISO_file = os.path.join(output_folder, the_name + ".xml")
   out_HTML_file = os.path.join(output_folder, the_name + ".html")
   if arcpy.Exists(out_ISO_file) == True or arcpy.Exists(out_HTML_file) == True:
      magic_number_found = False
      i = 2
      while magic_number_found == False:
         out_ISO_file = os.path.join(output_folder, the_name + str(i) + ".xml")
         out_HTML_file = os.path.join(output_folder, the_name + str(i) + ".html")
         if arcpy.Exists(out_ISO_file) == False and arcpy.Exists(out_HTML_file) == False:
            magic_number_found = True
         i += 1
   #WRITE OUTPUT METADATA-XML FILE
   make_note("Writing ISO metadata-XML file " + out_ISO_file + " ...")
   the_seed.write(out_ISO_file)
   #WRITE OUTPUT METADATA-HTML FILE
   make_note("Preparing output XML...")
   the_html = '<html>\n'
   the_html += '<!--*********************************************************************************'
   the_html += "DON'T ALTER THIS COMMENT. It's for VT DataRail WriteCoreMetadata tool use.\n"
   the_html += 'This HTML metadata-file was produced by the VT DataRail WriteCoreMetadata tool.\n'
   the_html += 'This file stores, in an HTML-comment, a Python dictionairy object called MetaContainer. The VT DataRail WriteCoreMetadata tool reads the MetaContainer object in order to provide a GUI for updating metadata.\n'
   the_html += 'The MetaContainer object must be enclosed by a MetaContainer tag (case sensitive).\n'
   the_html += '<MetaContainer>' + str(the_dictionary) + '</MetaContainer>\n'
   the_html += '<!--******************************************************************************-->\n'
   the_html += '   <body style="font-family:Calibri;font-size:12pt;">\n'
   the_html += '      <div style="font-size:16pt;">VT-GIS ISO-Core Metadata: <span style="font-weight:bold;">' + the_dictionary['title'] + '</span></div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Abstract</div>\n'
   #(REPLACE HARD RETURNS IN abstract W/ <br>)
   the_string = the_dictionary['abstract']
   the_string = the_string.replace("\n","<br>")
   the_html += '      <div>' + the_string + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Dataset Dates</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Data-Creation Date:</span> ' + the_dictionary['data_date_creation'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Data-Publication Date:</span> ' + the_dictionary['data_date_publication'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Data-Revision Date:</span> ' + the_dictionary['data_date_revision'] + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Points of Contact</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Organization:</span> ' + the_dictionary['poc_org'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Individual:</span> ' + the_dictionary['poc_individual'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Role:</span> ' + the_dictionary['poc_role'] + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Topics</div>\n'
   if the_dictionary['topics'] != "":
      topics_list = the_dictionary['topics'].split(",")
      for i in topics_list:
         the_html += i + '<br>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Extent (decimal degrees)</div>\n'
   the_html += '      <div><span style="font-weight:bold;">West:</span> ' + the_dictionary['extent_xmin'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">South:</span> ' + the_dictionary['extent_ymin'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">East:</span> ' + the_dictionary['extent_xmax'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">North:</span> ' + the_dictionary['extent_ymax'] + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Spatial Reference</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Codespace:</span> ' + the_dictionary['sref_codespace'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Code:</span> ' + the_dictionary['sref_code'] + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Metadata Date</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Metadata created or updated on:</span> ' + the_dictionary['metadata_date'] + '</div>\n'
   the_html += '      <p style="font-size:20pt;"></p>\n'
   the_html += '      <div style="font-size:14pt;font-weight:bold;">Other Info</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Metadata Language:</span> ' + the_dictionary['metadata_language'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Metadata Character-Coding:</span> ' + the_dictionary['metadata_charset'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Data Language:</span> ' + the_dictionary['data_language'] + '</div>\n'
   the_html += '      <div><span style="font-weight:bold;">Data Character-Coding:</span> ' + the_dictionary['data_charset'] + '</div>\n'
   the_html += '   </body>\n'
   the_html += '</html>\n'
   make_note("Writing metadata-HTML file " + out_HTML_file + " ...")
   the_output_html_file = open(out_HTML_file, "w")
   the_output_html_file.write(the_html)
   the_output_html_file.close()

try:
   #FIGURE OUT IF WORKING W/ A DATA ITEM OR AN HTML FILE (GET INPUT TYPE INTO A GLOBAL VARIABLE)
   make_note("Analyzing given arguments...")
   if data_item == "#" or data_item == "":
      if HTML_file[len(HTML_file) - 5:len(HTML_file)].lower() != ".html":
         if HTML_file[len(HTML_file) - 4:len(HTML_file)].lower() != ".htm":
            make_note("Expected an HTML file but didn't find one. Script terminated.", 2)
            sys.exit()
      input_type = "html"
   else:
      input_type = "item"

   #DECLARE VARIABLES FOR CAPTURING INFO (SOME OF THEM AREN'T IN USE UNTIL AFTER GUI INPUT)
   title = None
   abstract = None
   data_date_creation = None
   data_date_publication = None
   data_date_revision = None
   poc_org = None
   poc_individual = None
   poc_role = None
   topics = None
   extent_xmin = None
   extent_ymin = None
   extent_xmax = None
   extent_ymax = None
   sref_codespace = None
   sref_code = None
   metadata_date = None
   metadata_language = None
   metadata_charset = None
   data_language = None
   data_charset = None

   #IF GIVEN A DATA ITEM, GET INFO FROM vtDataRail_WriteCoreMetadata.INI.xml
   if input_type == 'item':
      try:
         make_note("Geting info from vtDataRail_WriteCoreMetadata.INI.xml...")
         ini_info = ET.parse(sys.path[0] + "\\vtDataRail_WriteCoreMetadata.INI.xml")
         settings = ini_info.getroot()
         for i in settings:
            setting_name = i.get("name").lower()
            if i.text != None:
               setting = i.text.strip()
            else:
               setting = ""
            #abstract
            if setting_name == "abstract" and setting != "":
               abstract = setting
            #poc_org
            if setting_name == "poc_org" and setting != "":
               poc_org = setting
            #poc_individual
            if setting_name == "poc_individual" and setting != "":
               poc_individual = setting
            #poc_role
            if setting_name == "poc_role" and setting != "":
               poc_role = setting
            #topics
            if setting_name == "topics" and setting != "":
               topics = setting
            #extent_xmin
            if setting_name == "extent_xmin" and setting != "":
               extent_xmin = setting
            #extent_ymin
            if setting_name == "extent_ymin" and setting != "":
               extent_ymin = setting
            #extent_xmax
            if setting_name == "extent_xmax" and setting != "":
               extent_xmax = setting
            #extent_ymax
            if setting_name == "extent_ymax" and setting != "":
               extent_ymax = setting
      except:
         make_note("Error occurred when reading vtDataRail_WriteCoreMetadata.INI.xml. Script terminated.", 2)
         sys.exit()

   #IF WORKING W/ AN HTML FILE, FIND, READ AND CAPTURE ITS "MetaContainer OBJECT"
   if input_type == 'html':
      MetaContainer = None
      the_input_HTML_file = open(HTML_file, "r")
      the_HTML = the_input_HTML_file.read()
      the_input_HTML_file.close()
      i = the_HTML.find('<MetaContainer>')
      if i != -1:
         i += 15
         j = the_HTML.find("</MetaContainer>", i)
         if j != -1:
            MetaContainer = ast.literal_eval(the_HTML[i:j])
      if MetaContainer == None or isinstance(MetaContainer, dict) == False:
         make_note("Couldn't find or couldn't interpret a MetaContainer in the HTML file. Script terminated.", 2)
         sys.exit()

   #IF WORKING W/ AN HTML FILE, GET ITS INFO
   if input_type == "html":
      title = MetaContainer['title']
      abstract = MetaContainer['abstract']
      data_date_creation = MetaContainer['data_date_creation']
      data_date_publication = MetaContainer['data_date_publication']
      data_date_revision = MetaContainer['data_date_revision']
      poc_org = MetaContainer['poc_org']
      poc_individual = MetaContainer['poc_individual']
      poc_role = MetaContainer['poc_role']
      topics = MetaContainer['topics']
      extent_xmin = MetaContainer['extent_xmin']
      extent_ymin = MetaContainer['extent_ymin']
      extent_xmax = MetaContainer['extent_xmax']
      extent_ymax = MetaContainer['extent_ymax']
      sref_codespace = MetaContainer['sref_codespace']
      sref_code = MetaContainer['sref_code']
      metadata_date = MetaContainer['metadata_date']
      metadata_language = MetaContainer['metadata_language']
      metadata_charset = MetaContainer['metadata_charset']
      data_language = MetaContainer['data_language']
      data_charset = MetaContainer['data_charset']

   #IF GIVEN A DATA ITEM, GET INFO ON DATA ITEM VIA arcpy.Describe() AND arcpy.ListFields()
   field_descriptions = None
   if input_type == "item":
      make_note("Analyzing data item to get more info...")
      #field_descriptions
      try:
         the_fields = arcpy.Describe(data_item).fields
         field_infos = []
         for i in the_fields:
            if i.type != "OID" and i.name.lower() != "shape":
               field_infos.append("-----" + i.name + ": " + i.aliasName)
         if len(field_infos) > 0:
            field_descriptions = "FIELD DESCRIPTIONS----------\n"
            for i in field_infos:
               field_descriptions += i + "\n"
            field_descriptions += "----------------------------"
      except:
         pass
      #extent_xmin (IF NOT SET VIA vtDataRail_WriteCoreMetadata.INI.xml)
      if extent_xmin == None:
         try:
            extent_xmin = arcpy.Describe(data_item).extent.projectAs(arcpy.SpatialReference(4326)).XMin
         except:
            pass
      #extent_ymin (IF NOT SET VIA vtDataRail_WriteCoreMetadata.INI.xml)
      if extent_ymin == None:
         try:
            extent_ymin = arcpy.Describe(data_item).extent.projectAs(arcpy.SpatialReference(4326)).YMin
         except:
            pass
      #extent_xmax (IF NOT SET VIA vtDataRail_WriteCoreMetadata.INI.xml)
      if extent_xmax == None:
         try:
            extent_xmax = arcpy.Describe(data_item).extent.projectAs(arcpy.SpatialReference(4326)).XMax
         except:
            pass
      #extent_ymax (IF NOT SET VIA vtDataRail_WriteCoreMetadata.INI.xml)
      if extent_ymax == None:
         try:
            extent_ymax = arcpy.Describe(data_item).extent.projectAs(arcpy.SpatialReference(4326)).YMax
         except:
            pass
      #sref_codespace AND sref_code
      sref_codespace = None
      sref_code = None
      try:
         sref_code = arcpy.Describe(data_item).spatialReference.factoryCode
         if sref_code in [32145,6589,3684,4269,3857,4326]:
            sref_codespace = "EPSG"
      except:
         pass

   #CREATE GUI
   #   A CONTENT CANVAS IS MADE FOR EACH CONTENT PORTION.
   #   EXCEPT FOR FIRST CONTENT CANVAS, OTHER CONTENT CANVASES DON'T INITIALLY APPEAR.
   the_GUI = Tkinter.Tk()
   the_GUI.title("VT DataRail Tools - Write Core Metadata")
   #ESTABLISH INITIAL CONTENT Canvas OBJECTS
   #Canvas for title, abstract
   canvas_title_and_abstract = Tkinter.Canvas(the_GUI)
   #Canvas for dates
   canvas_dates = Tkinter.Canvas(the_GUI)
   #Canvas for POCs
   canvas_pocs = Tkinter.Canvas(the_GUI)
   #Canvas for topics
   canvas_topics = Tkinter.Canvas(the_GUI)
   #Canvas for extent and spatial reference
   canvas_extent_sr = Tkinter.Canvas(the_GUI)
   #final Canvas
   canvas_final = Tkinter.Canvas(the_GUI)
   #FILL THE CANVASES
   #title
   Tkinter.Label(canvas_title_and_abstract, text="Title", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_title_and_abstract, text="Name by which the dataset is known, e.g., Fire Hydrants.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_title = Tkinter.Entry(canvas_title_and_abstract, font=("Calibri", 11), width=75)
   entry_title.grid(sticky=Tkinter.NW, padx=5)
   if title != None:
      entry_title.insert(Tkinter.END, title)
   Tkinter.Label(canvas_title_and_abstract, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #abstract
   Tkinter.Label(canvas_title_and_abstract, text="Abstract", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_title_and_abstract, text="Brief summary of dataset contents (1 or a few sentences).", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_title_and_abstract, text="Can insert a disclaimer here. Can insert field descriptions here.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   frame_abstract = Tkinter.Frame(canvas_title_and_abstract)
   text_abstract = Tkinter.Text(frame_abstract, font=("Calibri", 11), height=12, width=75)
   text_abstract.pack(side=Tkinter.LEFT)
   scroll_abstract = Tkinter.Scrollbar(frame_abstract)
   scroll_abstract.pack(side=Tkinter.RIGHT, fill=Tkinter.Y)
   text_abstract.config(yscrollcommand=scroll_abstract.set)
   scroll_abstract.config(command=text_abstract.yview)
   frame_abstract.grid(sticky=Tkinter.NW, padx=5)
   def add_field_descriptions():
      text_abstract.insert(Tkinter.END, field_descriptions)
   if abstract != None:
      text_abstract.insert(Tkinter.END, abstract)
   if input_type == 'item':
      if field_descriptions != None:
         Tkinter.Label(canvas_title_and_abstract, text="Data item has fields.", anchor=Tkinter.NW, font=("Calibri", 12), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
         Tkinter.Message(canvas_title_and_abstract, text="The ISO 19115 NAP standard doesn't have elements for documenting field descriptions. However, field descriptions can be very important. Therefore, including field descriptions in the abstract is highly recommended.\n\nBecause hard returns can vanish when metadata content is exported from one format to the other, consider prepending each field-description line with dashes (-----) to keep field descriptions from being difficult to read in case this metadata makes its way into an export operation that removes hard returns.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
         Tkinter.Button(canvas_title_and_abstract, text="Click to Add Starter Field-Description Text to End of Abstract", command=add_field_descriptions, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_title_and_abstract, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   def title_to_dates():
      canvas_title_and_abstract.grid_forget()
      canvas_dates.grid()
   Tkinter.Button(canvas_title_and_abstract, text="Next", command=title_to_dates, bg="dark green", fg="snow").grid(sticky=Tkinter.SE, padx=5)
   #(FIRST CONTENT Canvas IS ACTIVE BY DEFAULT)
   canvas_title_and_abstract.grid(row=0)
   #data_date_creation
   Tkinter.Label(canvas_dates, text="Data-Creation Date", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text="Date on which dataset was created, as YYYY-MM-DD, e.g., 2018-06-29.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_data_date_creation = Tkinter.Entry(canvas_dates, font=("Calibri", 11), width=20)
   entry_data_date_creation.grid(sticky=Tkinter.NW, padx=5)
   if data_date_creation != None:
      entry_data_date_creation.insert(Tkinter.END, data_date_creation)
   def add_data_date_creation():
      entry_data_date_creation.delete(0, Tkinter.END)
      entry_data_date_creation.insert(Tkinter.END, tell_the_time())
   Tkinter.Button(canvas_dates, text="Click to Auto-Fill w/ Today's Date", command=add_data_date_creation, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #data_date_publication
   Tkinter.Label(canvas_dates, text="Data-Publication Date", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text="Date on which dataset is/was published, as YYYY-MM-DD, e.g., 2018-06-29.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_data_date_publication = Tkinter.Entry(canvas_dates, font=("Calibri", 11), width=20)
   entry_data_date_publication.grid(sticky=Tkinter.NW, padx=5)
   if data_date_publication != None:
      entry_data_date_publication.insert(Tkinter.END, data_date_publication)
   def add_data_date_publication():
      entry_data_date_publication.delete(0, Tkinter.END)
      entry_data_date_publication.insert(Tkinter.END, tell_the_time())
   Tkinter.Button(canvas_dates, text="Click to Auto-Fill w/ Today's Date", command=add_data_date_publication, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_dates, text="Including a Data-Publication date is highly recommended, as it is directly translateable to the FGDC CSDGM metadata standard.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #data_date_revision
   Tkinter.Label(canvas_dates, text="Data-Revision Date", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text="Date on which dataset is/was revised, as YYYY-MM-DD, e.g., 2018-06-29.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_data_date_revision = Tkinter.Entry(canvas_dates, font=("Calibri", 11), width=20)
   entry_data_date_revision.grid(sticky=Tkinter.NW, padx=5)
   if data_date_revision != None:
      entry_data_date_revision.insert(Tkinter.END, data_date_revision)
   def add_data_date_revision():
      entry_data_date_revision.delete(0, Tkinter.END)
      entry_data_date_revision.insert(Tkinter.END, tell_the_time())
   Tkinter.Button(canvas_dates, text="Click to Auto-Fill w/ Today's Date", command=add_data_date_revision, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_dates, text="Best practice is to include at least 1 of the 3 dates. Data-Publication Date is directly translatable to the FGDC CSDGM format; the other dates aren't.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_dates, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   def dates_to_title():
      canvas_dates.grid_forget()
      canvas_title_and_abstract.grid()
   def dates_to_POCs():
      canvas_dates.grid_forget()
      canvas_pocs.grid()
   canvas_dates_buttons = Tkinter.Canvas(canvas_dates)
   Tkinter.Button(canvas_dates_buttons, text="Previous", command=dates_to_title, bg="dark green", fg="snow").grid(row=0, column=0, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_dates_buttons, text="Next", command=dates_to_POCs, bg="dark green", fg="snow").grid(row=0, column=1, sticky=Tkinter.SE, padx=5)
   canvas_dates_buttons.grid()
   #poc_org
   Tkinter.Label(canvas_pocs, text="Organization POC", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_pocs, text="Point-of-contact as an organization name, e.g., VT Agency of Natural Resources.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_poc_org = Tkinter.Entry(canvas_pocs, font=("Calibri", 11), width=50)
   entry_poc_org.grid(sticky=Tkinter.NW, padx=5)
   if poc_org != None:
      entry_poc_org.insert(Tkinter.END, poc_org)
   Tkinter.Message(canvas_pocs, text="Including an Organization POC is highly recommended, as it is directly translateable to the FGDC CSDGM metadata standard.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_pocs, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #poc_individual
   Tkinter.Label(canvas_pocs, text="Individual POC", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_pocs, text="Point-of-contact as an individual name, e.g., John Snow.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_poc_individual = Tkinter.Entry(canvas_pocs, font=("Calibri", 11), width=50)
   entry_poc_individual.grid(sticky=Tkinter.NW, padx=5)
   if poc_individual != None:
      entry_poc_individual.insert(Tkinter.END, poc_individual)
   Tkinter.Label(canvas_pocs, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #poc_role
   Tkinter.Label(canvas_pocs, text="Role POC", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_pocs, text="Point-of-contact as a role name, e.g., GIS Analyst.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_poc_role = Tkinter.Entry(canvas_pocs, font=("Calibri", 11), width=50)
   entry_poc_role.grid(sticky=Tkinter.NW, padx=5)
   if poc_role != None:
      entry_poc_role.insert(Tkinter.END, poc_role)
   Tkinter.Label(canvas_pocs, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_pocs, text="At least 1 of the 3 POCs must be populated; Organization POC is directly translateable to the FGDC CSDGM format; the other POCs aren't.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_pocs, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   def pocs_to_dates():
      canvas_pocs.grid_forget()
      canvas_dates.grid()
   def pocs_to_topics():
      canvas_pocs.grid_forget()
      canvas_topics.grid()
   canvas_pocs_buttons = Tkinter.Canvas(canvas_pocs)
   Tkinter.Button(canvas_pocs_buttons, text="Previous", command=pocs_to_dates, bg="dark green", fg="snow").grid(row=0, column=0, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_pocs_buttons, text="Next", command=pocs_to_topics, bg="dark green", fg="snow").grid(row=0, column=1, sticky=Tkinter.SE, padx=5)
   canvas_pocs_buttons.grid()
   #topics
   Tkinter.Label(canvas_topics, text="Topics", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_topics, text="Dataset's topic categories, separated by a ','.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_topics, text="Must have at least 1. For example: environment,inlandWaters.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_topics, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   list_topics = ["farming","biota","boundaries","climatologyMeteorologyAtmosphere","economy","elevation","environment","geoscientificInformation","health","imageryBaseMapsEarthCover","intelligenceMilitary","inlandWaters","location","oceans","planningCadastre","society","structure","transportation","utilitiesCommunication"]
   listbox_topics = Tkinter.Listbox(canvas_topics, width=35, height=19, selectmode=Tkinter.MULTIPLE)
   i = 0
   while i < len(list_topics):
      listbox_topics.insert(Tkinter.END, list_topics[i])
      i += 1
   listbox_topics.grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_topics, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   entry_topics = Tkinter.Entry(canvas_topics, font=("Calibri", 11), width=75)
   entry_topics.grid(sticky=Tkinter.NW, padx=5)
   if topics != None:
      entry_topics.insert(Tkinter.END, topics)
   def add_topics_to_input_box():
      selected_topics = listbox_topics.curselection()
      i = 0
      while i < len(selected_topics):
         if len(entry_topics.get()) > 0:
            entry_topics.insert(Tkinter.END, ",")
         entry_topics.insert(Tkinter.END, listbox_topics.get(int(selected_topics[i])))
         i += 1
   Tkinter.Button(canvas_topics, text="Click to Add Selected Topics to Input Box", command=add_topics_to_input_box, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_topics, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   def topics_to_pocs():
      canvas_topics.grid_forget()
      canvas_pocs.grid()
   def topics_to_extent():
      canvas_topics.grid_forget()
      canvas_extent_sr.grid()
   canvas_topics_buttons = Tkinter.Canvas(canvas_topics)
   Tkinter.Button(canvas_topics_buttons, text="Previous", command=topics_to_pocs, bg="dark green", fg="snow").grid(row=0, column=0, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_topics_buttons, text="Next", command=topics_to_extent, bg="dark green", fg="snow").grid(row=0, column=1, sticky=Tkinter.SE, padx=5)
   canvas_topics_buttons.grid()
   #extents
   Tkinter.Label(canvas_extent_sr, text="Extents", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_extent_sr, text="Dataset's extent boundaries, in decimal degrees.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_extent_sr, text='Reminder: Enter a "-" (minus) before values as needed. For example, in Vermont, longitude values are negative (e.g., -72.58051).', anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   if input_type == 'item':
      Tkinter.Message(canvas_extent_sr, text="If INI file has these values, they are auto-filled; otherwise, values are auto-detected and auto-filled when possible.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
      Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(extent_xmin)
   Tkinter.Label(canvas_extent_sr, text="West boundary of dataset's extent", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_extent_xmin = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_extent_xmin.grid(sticky=Tkinter.NW, padx=5)
   if extent_xmin != None:
      entry_extent_xmin.insert(Tkinter.END, extent_xmin)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(extent_ymin)
   Tkinter.Label(canvas_extent_sr, text="South boundary of dataset's extent", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_extent_ymin = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_extent_ymin.grid(sticky=Tkinter.NW, padx=5)
   if extent_ymin != None:
      entry_extent_ymin.insert(Tkinter.END, extent_ymin)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(extent_xmax)
   Tkinter.Label(canvas_extent_sr, text="East boundary of dataset's extent", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_extent_xmax = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_extent_xmax.grid(sticky=Tkinter.NW, padx=5)
   if extent_xmax != None:
      entry_extent_xmax.insert(Tkinter.END, extent_xmax)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(extent_ymax)
   Tkinter.Label(canvas_extent_sr, text="North boundary of dataset's extent", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_extent_ymax = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_extent_ymax.grid(sticky=Tkinter.NW, padx=5)
   if extent_ymax != None:
      entry_extent_ymax.insert(Tkinter.END, extent_ymax)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #spatial reference
   Tkinter.Label(canvas_extent_sr, text="Spatial-Reference Codespace and Code", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   if input_type == 'item':
      Tkinter.Message(canvas_extent_sr, text="This info is auto-detected and auto-filled when possible.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   #(sref_codespace)
   Tkinter.Label(canvas_extent_sr, text="Codespace of dataset's spatial reference, e.g., EPSG", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_sref_codespace = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_sref_codespace.grid(sticky=Tkinter.NW, padx=5)
   if sref_codespace != None:
      entry_sref_codespace.insert(Tkinter.END, sref_codespace)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(sref_code)
   Tkinter.Label(canvas_extent_sr, text="Spatial-Reference Code, e.g., 32145", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_sref_code = Tkinter.Entry(canvas_extent_sr, font=("Calibri", 11), width=10)
   entry_sref_code.grid(sticky=Tkinter.NW, padx=5)
   if sref_code != None:
      entry_sref_code.insert(Tkinter.END, sref_code)
   Tkinter.Message(canvas_extent_sr, text="Dataset's spatial-reference code. EPSG codes can be obtained from http://spatialreference.org.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_extent_sr, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   def extent_to_topics():
      canvas_extent_sr.grid_forget()
      canvas_topics.grid()
   def extent_to_final():
      canvas_extent_sr.grid_forget()
      canvas_final.grid()
   canvas_extent_sr_buttons = Tkinter.Canvas(canvas_extent_sr)
   Tkinter.Button(canvas_extent_sr_buttons, text="Previous", command=extent_to_topics, bg="dark green", fg="snow").grid(row=0, column=0, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_extent_sr_buttons, text="Next", command=extent_to_final, bg="dark green", fg="snow").grid(row=0, column=1, sticky=Tkinter.SE, padx=5)
   canvas_extent_sr_buttons.grid()
   #final canvas...  metadata_date and more
   Tkinter.Label(canvas_final, text="The final panel!", anchor=Tkinter.NW, font=("Calibri", 14), fg="red").grid(sticky=Tkinter.NW, padx=5)
   #(metadata_date)
   Tkinter.Label(canvas_final, text="Metadata Date", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_final, text="Date metadata was created/updated, as YYYY-MM-DD hh:mm:ss, e.g., 2018-06-29.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   entry_metadata_date = Tkinter.Entry(canvas_final, font=("Calibri", 11), width=20)
   entry_metadata_date.grid(sticky=Tkinter.NW, padx=5)
   if metadata_date != None:
      entry_metadata_date.insert(Tkinter.END, metadata_date)
   def add_metadata_date():
      entry_metadata_date.delete(0, Tkinter.END)
      entry_metadata_date.insert(Tkinter.END, tell_the_time())
   Tkinter.Button(canvas_final, text="Click to Auto-Fill w/ Today's Date", command=add_metadata_date, bg="gold").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(more)
   Tkinter.Label(canvas_final, text="Language and Character Coding", anchor=Tkinter.NW, font=("Calibri", 14), relief=Tkinter.GROOVE, bg="PaleGreen").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_final, text="Metadata language, metadata character coding, data language, and data character coding.", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_final, text="This information is pre-populated. It is the least likely info to need alteration.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(metadata_language)
   Tkinter.Label(canvas_final, text="Metadata Language", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_final, text='3-character ISO 639-2/T for metadata language. 3-letter language code followed by a 3-letter country code, separated by “; ”. Use "eng; USA" for English in the USA.', anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   entry_metadata_language = Tkinter.Entry(canvas_final, font=("Calibri", 11), width=20)
   entry_metadata_language.grid(sticky=Tkinter.NW, padx=5)
   if metadata_language != None:
      entry_metadata_language.insert(Tkinter.END, metadata_language)
   else:
      entry_metadata_language.insert(Tkinter.END, "eng; USA")
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(metadata_charset)
   Tkinter.Label(canvas_final, text="Metadata Character-Coding", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_final, text='Use "utf8".', anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   entry_metadata_charset = Tkinter.Entry(canvas_final, font=("Calibri", 11), width=20)
   entry_metadata_charset.grid(sticky=Tkinter.NW, padx=5)
   if metadata_charset != None:
      entry_metadata_charset.insert(Tkinter.END, metadata_charset)
   else:
      entry_metadata_charset.insert(Tkinter.END, "utf8")
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(data_language)
   Tkinter.Label(canvas_final, text="Data Language", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_final, text='3-character ISO 639-2/T for data language. Use "eng" for English.', anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   entry_data_language = Tkinter.Entry(canvas_final, font=("Calibri", 11), width=20)
   entry_data_language.grid(sticky=Tkinter.NW, padx=5)
   if data_language != None:
      entry_data_language.insert(Tkinter.END, data_language)
   else:
      entry_data_language.insert(Tkinter.END, "eng")
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #(data_charset)
   Tkinter.Label(canvas_final, text="Data Character-Coding", anchor=Tkinter.NW, font=("Calibri", 12)).grid(sticky=Tkinter.NW, padx=5)
   Tkinter.Message(canvas_final, text="Data's character-coding, Use " + '"utf8"' + " unless have oddball coding.", anchor=Tkinter.NW, width=500, font=("Calibri", 9), bg="light yellow").grid(sticky=Tkinter.NW, padx=5)
   entry_data_charset = Tkinter.Entry(canvas_final, font=("Calibri", 11), width=20)
   entry_data_charset.grid(sticky=Tkinter.NW, padx=5)
   if data_charset != None:
      entry_data_charset.insert(Tkinter.END, data_charset)
   else:
      entry_data_charset.insert(Tkinter.END, "utf8")
   Tkinter.Label(canvas_final, text=" ", anchor=Tkinter.NW, font=("Calibri", 14)).grid(sticky=Tkinter.NW, padx=5)
   #BUTTONS
   canvas_final_buttons = Tkinter.Canvas(canvas_final)
   def final_to_extent():
      canvas_final.grid_forget()
      canvas_extent_sr.grid()
   def go_write_metadata():
      #REMOVE BUTTONS, SHOW STATUS
      canvas_final_buttons.grid_forget()
      info_label = Tkinter.Label(canvas_final, text="Processing input...", anchor=Tkinter.NW, font=("Calibri", 14), fg="red")
      info_label.grid(sticky=Tkinter.SE, padx=5)
      make_note("Processing input...")
      #COLLECT GUI INFO INTO A "MetaContainer" DICTIONARY
      #title
      title = entry_title.get()
      #abstract
      abstract = text_abstract.get(1.0, Tkinter.END)
      #data_date_creation
      data_date_creation = entry_data_date_creation.get()
      #data_date_publication
      data_date_publication = entry_data_date_publication.get()
      #data_date_revision
      data_date_revision = entry_data_date_revision.get()
      #poc_org
      poc_org = entry_poc_org.get()
      #poc_individual
      poc_individual = entry_poc_individual.get()
      #poc_role
      poc_role = entry_poc_role.get()
      #topics
      topics = entry_topics.get()
      #extent_xmin
      extent_xmin = entry_extent_xmin.get()
      #extent_ymin
      extent_ymin = entry_extent_ymin.get()
      #extent_xmax
      extent_xmax = entry_extent_xmax.get()
      #extent_ymax
      extent_ymax = entry_extent_ymax.get()
      #sref_codespace
      sref_codespace = entry_sref_codespace.get()
      #sref_code
      sref_code = entry_sref_code.get()
      #metadata_date
      metadata_date = entry_metadata_date.get()
      #metadata_language
      metadata_language = entry_metadata_language.get()
      #metadata_charset
      metadata_charset = entry_metadata_charset.get()
      #data_language
      data_language = entry_data_language.get()
      #data_charset
      data_charset = entry_data_charset.get()
      the_info = {'title':title,'abstract':abstract,'data_date_creation':data_date_creation,'data_date_publication':data_date_publication,'data_date_revision':data_date_revision,'poc_org':poc_org,'poc_individual':poc_individual,'poc_role':poc_role,'topics':topics,'extent_xmin':extent_xmin,'extent_ymin':extent_ymin,'extent_xmax':extent_xmax,'extent_ymax':extent_ymax,'sref_codespace':sref_codespace,'sref_code':sref_code,'metadata_date':metadata_date,'metadata_language':metadata_language,'metadata_charset':metadata_charset,'data_language':data_language,'data_charset':data_charset}
      #SEND THE "MetaContainer" DICTIONAIRY TO metadata_writer(), WHICH WRITES OUTPUT XML AND HTML FILES
      metadata_writer(the_info)
      #FINALLY, EXIT GUI
      make_note("Script completed.")
      the_GUI.destroy()
   def go_exit():
      the_GUI.destroy()
   Tkinter.Button(canvas_final_buttons, text="Previous", command=final_to_extent, bg="dark green", fg="snow").grid(row=0, column=0, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_final_buttons, text="Save Metadata To XML and HTML", command=go_write_metadata, bg="dark green", fg="snow").grid(row=0, column=1, sticky=Tkinter.SE, padx=5)
   Tkinter.Button(canvas_final_buttons, text="Exit W/O Saving", command=go_exit, bg="dark green", fg="snow").grid(row=0, column=3, sticky=Tkinter.SE, padx=5)
   canvas_final_buttons.grid()

   #GUI's mainloop
   make_note("GUI open...")
   Tkinter.mainloop()

except:
   make_note("Script failed due to error condition.", 2)
   make_note("arcpy MESSAGES:\n" + arcpy.GetMessages())
